---
title: "Análisis temporal para la temperatura promedio semanal en Nueva Delhi"
author: "Jose Daniel Gallego Giraldo"
date: "`r Sys.Date()`"
output:
  github_document:
    toc: true
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  fig.width = 10,
  fig.height = 5,
  fig.path = "figs/"
)

library(lmtest)
library(urca)
library(matrixcalc)
library(aTSA)
library(MASS)
library(TSA)
library(pastecs)
library(dplyr)
library(stats)
library(astsa)
library(forecast)
library(tseries)
library(nortest)
library(fBasics)
library(car)
library(MLmetrics)
library(fTrading)
library(ggplot2)
library(zoo)
library(lubridate)
library(tidyr)
```

## 1) Carga y preparación de datos diarios
```{r carga_preparacion, message=FALSE, warning=FALSE}
DailyDelhiClimateTrain <- read.csv("DailyDelhiClimateTrain.csv")
DailyDelhiClimateTest  <- read.csv("DailyDelhiClimateTest.csv")
Entreno <- (DailyDelhiClimateTrain)
Testeo  <- (DailyDelhiClimateTest)

### TRANSFORMEMOS LA SERIE DE MEDIAS DIARIAS A MEDIAS SEMANALES

df_temp_diaria <- DailyDelhiClimateTrain %>%
  mutate(date = seq(as.Date("2013-01-01"), by = "day",
                    length.out = nrow(DailyDelhiClimateTrain)))
```


## 2) Promedio semanal (train) y `ts`; preparación de fechas (test)
```{r semanal_y_ts, message=FALSE, warning=FALSE}
# Calcular promedio semanal de la temperatura media para el train
df_temp_semanal <- df_temp_diaria %>%
  mutate(semana = floor_date(date, unit = "week")) %>%
  group_by(semana) %>%
  summarise(mean_temp = mean(meantemp, na.rm = TRUE))

ts_temp_semanal <- ts(df_temp_semanal$mean_temp, 
                      start = c(2013, 1), 
                      frequency = 52)

# Preparar data.frame diario para el set de test (con columna 'date')
df_temp_diaria_test <- DailyDelhiClimateTest %>%
  mutate(date = seq(as.Date("2017-01-01"), by = "day",
                    length.out = nrow(DailyDelhiClimateTest)))
```


## 3) Promedio semanal (test) y objeto `ts`
```{r semanal_test_ts, message=FALSE, warning=FALSE}
# Calcular promedio semanal de la temperatura media para el test
df_temp_semanal_test <- df_temp_diaria_test %>%
  mutate(semana = floor_date(date, unit = "week")) %>%
  group_by(semana) %>%
  summarise(mean_temp = mean(meantemp, na.rm = TRUE))

# Crear objeto ts semanal
ts_temp_semanal_test <- ts(df_temp_semanal_test$mean_temp, 
                           start = c(2017, 1), 
                           frequency = 52)
```


## 4) Visualización de la serie temporal semanal (train)
```{r grafico_serie_semanal, message=FALSE, warning=FALSE}
options(repr.plot.width = 14, repr.plot.height = 8)

ts.plot(ts_temp_semanal,
        ylab = "Temperatura promedio",
        main = "Serie del promedio de temperatura semanal",
        lwd = 2)

grid(col = "black")

##GRAFICAMENTE OBSERVAMOS QUE SE PRESENTA UNA ESTACIONALIDAD CADA ANO APROXIMADAMENTE Y UNA VARIANZA APROXIMADAMENTE 
##CONSTANTE POR LO QUE NO APLICAREMOS UNA TRANSFOMRACION DE BOX COX
```


## 5) Descomposición aditiva de la serie temporal semanal
```{r descomposicion, message=FALSE, warning=FALSE}
##OBSERVEMOS UNA DESCOMPOSICION ADITIVA CON EL FIN DE TENER INDICIOS SOBRE LA ESTACIONALIDAD Y
##LA POSIBLE TENDENCIA DE LA SERIE
descomp <- decompose(ts_temp_semanal)
plot(descomp)
##OBSERVAMOS UNA CLARA ESTACIONALIDAD ADEMAS DE OBSERVAR UNA TENDENCIA A LA ALZA POR PARTE DE LA SERIE, 
##POR LO QUE PODRIAMOS ESPERAR QUE LA TEMPERATURA MEDIA SEMANAL ESTE AUMENTANDO, ESTO PUEDE
##DEVERSE A DIFERENTES FACTORES, COMO POSIBLES DE ELLOS EL CALENTAMIENTO GLOBAL
```


## 6) Prueba de estacionariedad (Dickey–Fuller aumentada)
```{r estacionariedad, message=FALSE, warning=FALSE}
## REALICEMOS UN TEST DE ESTACIONARIEDAD

df <- adf.test(ts_temp_semanal)
df

## LA PRUEBA NOS DA COMO RESULTADO QUE LA SERIE ES ESTACIONARIA  
adf_ur <- ur.df(ts_temp_semanal, type = "trend", lags = 5)

# Ver resultado
summary(adf_ur)

## OBSERVAMOS QUE LA SERIE CUMPLE EL SUPUESTO DE ESTACIONARIEDAD MEDIANTE LA PRUEBA DE DICKEY–FULLER
```


## 7) Prueba de homogeneidad de varianzas (Levene)
```{r homogeneidad_varianza, message=FALSE, warning=FALSE}
## AHORA MIREMOS LA PRUEBA DE HOMOGENEIDAD DE VARIANZAS DE LEVENE

segmentos <- cut(1:length(ts_temp_semanal), breaks = 52)

# Prueba de Levene
pl <- leveneTest(ts_temp_semanal ~ segmentos)
print(pl)

## OBSERVAMOS QUE NO RECHAZAMOS H0, POR LO QUE HAY HOMOGENEIDAD DE VARIANZAS DE FORMA ANUAL,
## LO QUE SE EVIDENCIA EN EL GRÁFICO PUES HAY UN GRAN PARECIDO EN LA SERIE A LO LARGO DE LOS AÑOS
```


## 8) Boxplots mensuales (temperaturas promedio)
```{r boxplots_mensuales, message=FALSE, warning=FALSE}
## BOXPLOTS MENSUALES

fechas <- seq(as.Date("2013-01-01"), by = "week", length.out = length(ts_temp_semanal))
datos <- data.frame(Fecha = fechas, Valor = ts_temp_semanal)

tamaño_ventana <- 4  ## TOMAR UNA VENTANA MÁS ALTA, POR EJEMPLO 30 → TRIMESTRAL O SEMESTRAL

datos <- datos %>%
  mutate(
    Semana  = as.numeric(difftime(Fecha, min(Fecha), units = "weeks")),
    Ventana = ceiling(Semana / tamaño_ventana)
  )

ggplot(datos, aes(x = as.factor(Ventana), y = Valor)) +
  geom_boxplot(fill = "skyblue", color = "darkblue") +
  labs(
    title = "Boxplot por Ventana de Temperaturas Promedio Mensual",
    x = "Ventana",
    y = "Temperatura promedio (°C)"
  ) +
  theme_minimal()
```


## 9) ACF, PACF y diferenciación de la serie
```{r acf_pacf_diferenciacion, message=FALSE, warning=FALSE}
## ACF y PACF de la serie original
par(mfrow = c(2, 1))
acf(ts_temp_semanal, lag.max = 156, main = "ACF de la serie")
pacf(ts_temp_semanal, lag.max = 156, main = "PACF de la serie")

## TENEMOS SOSPECHAS DE QUE LA SERIE EN REALIDAD NO ES ESTACIONARIA,
## PUES LA ACF PRESENTA UN DECAIMIENTO LENTO.
## APLIQUEMOS UNA PRIMERA DIFERENCIA A LA SERIE.

par(mfrow = c(1, 1))
ts_temp_semanal_dif <- diff(ts_temp_semanal)

ts.plot(ts_temp_semanal_dif,
        ylab = "Temperatura promedio",
        main = "Serie del promedio de temperatura semanal diferenciada",
        lwd = 2)
grid(col = "black")

## AHORA CON LA PRIMERA DIFERENCIA OBSERVAMOS UN PATRÓN ESTACIONARIO
```


## 10) ACF y PACF de la serie diferenciada y diferenciación estacional
```{r acf_pacf_dif_estacional, message=FALSE, warning=FALSE}
## ACF y PACF de la serie diferenciada (para confirmar estacionariedad)
par(mfrow = c(2, 1))
acf(ts_temp_semanal_dif, lag.max = 156, main = "ACF de la serie diferenciada")
pacf(ts_temp_semanal_dif, lag.max = 156, main = "PACF de la serie diferenciada")

### APLIQUEMOS LA DIFERENCIACIÓN ESTACIONAL
par(mfrow = c(2, 1))

# ACF aplicando diferencia estacional cada 52 semanas
acf(diff(ts_temp_semanal_dif, lag = 52),
    lag.max = 156,
    main = "ACF aplicando diferencia estacional cada 52 semanas")

# PACF aplicando diferencia estacional cada 52 semanas
pacf(diff(ts_temp_semanal_dif, lag = 52),
     lag.max = 156,
     main = "PACF aplicando diferencia estacional cada 52 semanas")

## OBSERVAMOS UN PICO FUERTE EN EL LAG = 1 (52 SEMANAS)
## Y UN POSIBLE DECAIMIENTO EXPONENCIAL EN LA PACF,
## POR LO QUE EL MODELO ELEGIDO PODRÍA SER UNO CON UNA MEDIA MÓVIL ESTACIONAL CADA 52 SEMANAS
```


## 11) Búsqueda y ajuste del mejor modelo SARIMA
```{r modelo_sarima, message=FALSE, warning=FALSE}
library(astsa)

# Definir los órdenes base
p <- 1; q <- 1
P <- 1; Q <- 1
d <- 1; D <- 1
S <- 52  # Periodo estacional anual

# Cantidad total de combinaciones
maxfilas <- (p + 1) * (q + 1) * (P + 1) * (Q + 1)

# Matriz para guardar resultados
ic_mod <- matrix(NA, nrow = maxfilas, ncol = 6)
colnames(ic_mod) <- c("p", "q", "P", "Q", "AIC", "BIC")

# Iterar modelos
k <- 1
for (i in 0:p) {
  for (j in 0:q) {
    for (s in 0:P) {
      for (m in 0:Q) {
        cat("Evaluando modelo (", i, d, j, ") x (", s, D, m, ")[", S, "]\n")
        
        ajuste <- tryCatch({
          mod <- sarima(ts_temp_semanal,
                        p = i, d = d, q = j,
                        P = s, D = D, Q = m, S = S,
                        details = FALSE, no.constant = TRUE)
          ic_mod[k, ] <- c(i, j, s, m, mod$AIC, mod$BIC)
        },
        error = function(e) {
          cat("Error con modelo (", i, d, j, ") x (", s, D, m, "): ", e$message, "\n")
          ic_mod[k, ] <- c(i, j, s, m, NA, NA)
        })
        k <- k + 1
      }
    }
  }
}

# Ver resultados ordenados por AIC
ic_mod_ordenado <- ic_mod[order(ic_mod[, 5], na.last = NA), ]
print(ic_mod_ordenado)

## OBSERVAMOS QUE EL MEJOR MODELO SEGÚN AIC Y BIC ES SARIMA (1,1,1)×(0,1,1)[52],
## LO CUAL ES COHERENTE CON LA ACF Y PACF (DIFERENCIACIÓN ORDINARIA Y ESTACIONAL).

modelo_seleccionado <- sarima(ts_temp_semanal,
                              p = 1, d = 1, q = 1,
                              P = 0, D = 1, Q = 1,
                              S = 52,
                              details = TRUE,
                              no.constant = TRUE)

# Análisis de residuos
res_mod <- modelo_seleccionado$fit$residuals
Box.test(res_mod, type = "Ljung-Box")  ## Verifica que los residuos no estén correlacionados
ajust <- ts_temp_semanal - res_mod
```


## 12) Gráfico de valores ajustados vs. observados
```{r grafico_valores_ajustados, message=FALSE, warning=FALSE}
# Gráfico para los valores ajustados
par(mfrow = c(1, 1))
ts.plot(ts_temp_semanal, ajust, main = "Valores ajustados vs serie original")
lines(ts_temp_semanal, col = "red")

## OBSERVAMOS A GRANDES RASGOS QUE LOS RESIDUALES NO ESTÁN CORRELACIONADOS,
## Y QUE EL MODELO APUNTA MUY BIEN, PUES AL COMPARAR LOS VALORES AJUSTADOS CON LA SERIE REAL,
## SE EVIDENCIA UN BUEN COMPORTAMIENTO.
```


## 13) Evaluación del modelo: cálculo del MAPE
```{r evaluacion_mape, message=FALSE, warning=FALSE}
## OBSERVEMOS EL MAPE
h <- length(ts_temp_semanal_test)
predicciones <- predict(modelo_seleccionado$fit, n.ahead = h)
##COMPARAMOS LAS PREDDICIONES CON LOS VALORES DE TESTEO
ts.plot(ts_temp_semanal, predicciones$pred, col = c("black", "blue"))
lines(ts_temp_semanal_test, col = "red")  # Valores reales en rojo
legend("topleft", legend = c("Entrenamiento", "Predicción", "Real"),
       col = c("black", "blue", "red"), lty = 1)

longitud <- min(length(predicciones$pred), length(ts_temp_semanal_test))

# Cálculo del MAPE
mp <- MAPE(predicciones$pred, ts_temp_semanal_test) * 100
cat("MAPE del modelo (%):", round(mp, 2), "\n")
```


## 14) Incorporación de variables exógenas (promedios semanales)
```{r variables_exogenas, message=FALSE, warning=FALSE}
## AHORA QUE TENEMOS UNA IDEA DE QUÉ MODELO ELEGIR, APLICAREMOS VARIABLES EXÓGENAS PARA EVALUAR COHERENCIA

## MATRICES DE VARIABLES EXÓGENAS
X_train <- as.matrix(Entreno[, c("humidity", "wind_speed", "meanpressure")])
X_test  <- as.matrix(Testeo[,  c("humidity", "wind_speed", "meanpressure")])

## CONVERTIMOS LAS VARIABLES EXÓGENAS A VALORES SEMANALES TAMBIÉN
Entreno_semanal <- Entreno %>%
  mutate(date = as.Date(date),
         semana = floor_date(date, "week")) %>%
  group_by(semana) %>%
  summarise(
    humidity = mean(humidity, na.rm = TRUE),
    wind_speed = mean(wind_speed, na.rm = TRUE),
    meanpressure = mean(meanpressure, na.rm = TRUE)
  )

# Para el conjunto de prueba
Testeo_semanal <- Testeo %>%
  mutate(date = as.Date(date),
         semana = floor_date(date, "week")) %>%
  group_by(semana) %>%
  summarise(
    humidity = mean(humidity, na.rm = TRUE),
    wind_speed = mean(wind_speed, na.rm = TRUE),
    meanpressure = mean(meanpressure, na.rm = TRUE)
  )
```



## 15) Series temporales semanales de variables exógenas y gráficos
```{r ts_exogenas_graficos, message=FALSE, warning=FALSE}
## SACAMOS LAS SERIES DE TIEMPO RELACIONADAS A LAS VARIABLES EXOGENAS

ts_humedad_semanal <- ts(Entreno_semanal$humidity,
                         start = c(2013, 1),
                         frequency = 52)

ts_velocidad_viento_semalan <- ts(Entreno_semanal$wind_speed,
                                  start = c(2013, 1),
                                  frequency = 52)

ts_presion_media_semanal <- ts(Entreno_semanal$meanpressure,
                               start = c(2013, 1),
                               frequency = 52)

## REALIZAMOS LOS GRÁFICOS
par(mfrow = c(4, 1), mar = c(4, 4, 2, 1))  # márgenes ajustados

# Graficar cada serie de tiempo
plot(ts_temp_semanal, col = "tomato", lwd = 2,
     main = "Temperatura semanal", xlab = "Semana", ylab = "°C")

plot(ts_humedad_semanal, col = "steelblue", lwd = 2,
     main = "Humedad semanal", xlab = "Semana", ylab = "%")

plot(ts_velocidad_viento_semalan, col = "forestgreen", lwd = 2,
     main = "Velocidad del viento semanal", xlab = "Semana", ylab = "m/s")

plot(ts_presion_media_semanal, col = "darkorange", lwd = 2,
     main = "Presión media semanal", xlab = "Semana", ylab = "hPa")
```


## 16) Coherencia espectral entre temperatura y exógenas
```{r coherencia_espectral, message=FALSE, warning=FALSE}


par(mfrow = c(3, 1))

# Periodogramas multivariados suavizados 
graficoc_coherencia  <- mvspec(cbind(ts_temp_semanal, ts_humedad_semanal),         spans = 7, kernel = "daniell")
graficoc_coherencia2 <- mvspec(cbind(ts_temp_semanal, ts_velocidad_viento_semalan), spans = 7, kernel = "daniell")
graficoc_coherencia3 <- mvspec(cbind(ts_temp_semanal, ts_presion_media_semanal),    spans = 7, kernel = "daniell")

# Extraer frecuencias y coherencia (ejemplo: temperatura ~ humedad)
frecuencias        <- graficoc_coherencia$freq          
coherencia         <- Mod(graficoc_coherencia$coh)^2   
periodos_semanales <- 1 / frecuencias                   

# Tabla ordenada por coherencia (picos)
df <- data.frame(
  Periodo_semanas = periodos_semanales,
  Coherencia      = coherencia
)
df_ordenado <- df[order(-df$Coherencia), ]
head(df_ordenado, 5)

## OBSERVACIÓN:
## En los periodogramas suavizados se aprecian picos a frecuencias cortas (≈ 1/52),
## lo que sugiere estacionalidad anual (52 semanas) en las series.
```


## 17) Ajuste del modelo SARIMA con variables exógenas
```{r sarima_exogenas, message=FALSE, warning=FALSE}
## RECORDEMOS EL MODELO SELECCIONADO (SARIMA) Y AGREGUEMOS LAS EXÓGENAS
## EVALUAREMOS SU AJUSTE Y LOS VALORES P DE SIGNIFICANCIA,
## ASÍ COMO EL PRONÓSTICO Y EL MAPE.

# CONFIGURAMOS LAS MATRICES
Entreno_xreg <- Entreno_semanal %>%
  select(humidity, wind_speed, meanpressure) %>%
  mutate(across(everything(), as.numeric)) %>%
  as.matrix()

Testeo_xreg <- Testeo_semanal %>%
  select(humidity, wind_speed, meanpressure) %>%
  mutate(across(everything(), as.numeric)) %>%
  as.matrix()

## AJUSTAMOS EL MODELO SARIMA CON VARIABLES EXÓGENAS
modelo_exogenas <- Arima(ts_temp_semanal,
                         order = c(1, 1, 1),
                         seasonal = list(order = c(0, 1, 1), period = 52),
                         method = "CSS-ML",
                         xreg = Entreno_xreg)

n_a_predecir <- nrow(Testeo_xreg)
```


## 18) Predicción y visualización del modelo con variables exógenas
```{r prediccion_exogenas, message=FALSE, warning=FALSE}
## REALIZAMOS LA PREDICCIÓN CON LAS VARIABLES EXÓGENAS
prediccion <- forecast(modelo_exogenas, xreg = Testeo_xreg, h = n_a_predecir)

par(mfrow = c(1, 1))
plot(prediccion, main = "Predicción de temperatura media semanal")
lines(ts_temp_semanal_test, col = "red", lwd = 2)
legend("topleft",
       legend = c("Observado", "Predicción"),
       col = c("red", "blue"),
       lty = 1, lwd = 2)

## GRAFICAMOS LA PREDICCIÓN CON GGPLOT
autoplot(prediccion) +
  autolayer(ts_temp_semanal_test, series = "Real", color = "red") +
  ggtitle("Pronóstico ARIMAX vs Observado") +
  theme_minimal()
```



## 19) Evaluación del modelo con exógenas: significancia y MAPE
```{r evaluacion_exogenas, message=FALSE, warning=FALSE}
## AHORA CALCULEMOS EL MAPE Y MIREMOS LA SIGNIFICANCIA DE LAS VARIABLES EXÓGENAS

# Resumen general del modelo
summary(modelo_exogenas)

# Coeficientes estimados
coefs <- summary(modelo_exogenas)$coef
print(coefs)

# Prueba de significancia estadística de los coeficientes
coeftest(modelo_exogenas)
```



## 20) Evaluación del ajuste del modelo ARIMAX mediante residuos
```{r evaluacion_residuos_exogenas, message=FALSE, warning=FALSE}
## FORMA DE EVALUAR EL BUEN AJUSTE DEL MODELO CON VARIABLES EXÓGENAS:
## OBSERVAR LA ACF Y PACF DE LOS RESIDUALES DEL MODELO

# Prueba de independencia de residuos (Ljung–Box)
Box.test(modelo_exogenas$residuals, lag = 20, type = "Ljung-Box")

# ACF de los residuos
acf(modelo_exogenas$residuals, main = "ACF de los residuos del modelo ARIMAX")

# PACF de los residuos
pacf(modelo_exogenas$residuals, main = "PACF de los residuos del modelo ARIMAX")
```




